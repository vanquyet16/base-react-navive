import axios, { AxiosError, InternalAxiosRequestConfig, AxiosResponse } from 'axios';
import { API_CONFIG, ERROR_MESSAGES } from '@/constants';
import { useAuthStore } from '@/stores/authStore';
import { CustomAxiosRequestConfig } from '@/types';
import Toast from 'react-native-toast-message';

// T·∫°o axios instance
const api = axios.create({
    baseURL: API_CONFIG.BASE_URL,
    timeout: API_CONFIG.TIMEOUT,
    headers: {
        'Content-Type': 'application/json',
    },
});

// Interceptor request
api.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
        const { tokens } = useAuthStore.getState();

        if (tokens?.token) {
            config.headers.Authorization = `Bearer ${tokens.token}`;
        }

        if (__DEV__) {
            console.log(`üöÄ [${config.method?.toUpperCase()}] ${config.url}`, {
                params: config.params,
                data: config.data,
            });
        }

        return config;
    },
    (error: AxiosError) => {
        if (__DEV__) {
            console.error('‚ùå Request Error:', error);
        }
        return Promise.reject(error);
    },
);

// Interceptor response
api.interceptors.response.use(
    (response: AxiosResponse) => {
        if (__DEV__) {
            console.log(`‚úÖ [${response.status}] ${response.config.url}`, response.data);
        }
        return response;
    },
    async (error: AxiosError) => {
        const originalRequest = error.config as CustomAxiosRequestConfig;

        if (__DEV__) {
            console.error(`‚ùå [${error.response?.status}] ${error.config?.url}`, error.response?.data);
        }

        // X·ª≠ l√Ω l·ªói 401 Unauthorized
        if (error.response?.status === 401 && originalRequest && !originalRequest._retry) {
            originalRequest._retry = true;

            const { tokens, logout, updateTokens } = useAuthStore.getState();

            if (tokens?.refreshToken) {
                try {
                    // Th·ª≠ l√†m m·ªõi token
                    const refreshResponse = await axios.post(
                        `${API_CONFIG.BASE_URL}/auth/refresh`,
                        { refreshToken: tokens.refreshToken },
                    );

                    const newTokens = refreshResponse.data.tokens;
                    updateTokens(newTokens);

                    // Th·ª≠ l·∫°i request g·ªëc v·ªõi token m·ªõi
                    if (originalRequest.headers) {
                        originalRequest.headers.Authorization = `Bearer ${newTokens.accessToken}`;
                    } else {
                        originalRequest.headers = { Authorization: `Bearer ${newTokens.accessToken}` };
                    }

                    return api(originalRequest);
                } catch (refreshError) {
                    // L√†m m·ªõi token th·∫•t b·∫°i, ƒëƒÉng xu·∫•t ng∆∞·ªùi d√πng
                    logout();
                    Toast.show({
                        type: 'error',
                        text1: 'Phi√™n ƒëƒÉng nh·∫≠p h·∫øt h·∫°n',
                        text2: 'Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i',
                    });
                    return Promise.reject(refreshError);
                }
            } else {
                // Kh√¥ng c√≥ refresh token, ƒëƒÉng xu·∫•t ng∆∞·ªùi d√πng
                logout();
                Toast.show({
                    type: 'error',
                    text1: 'Phi√™n ƒëƒÉng nh·∫≠p h·∫øt h·∫°n',
                    text2: 'Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i',
                });
            }
        }

        // X·ª≠ l√Ω c√°c l·ªói kh√°c
        let errorMessage = ERROR_MESSAGES.SERVER_ERROR;

        if (error.code === 'ECONNABORTED' || (error.message && typeof error.message === 'string' && error.message.includes('timeout'))) {
            errorMessage = 'Timeout - Vui l√≤ng th·ª≠ l·∫°i';
        } else if (error.code === 'ERR_NETWORK') {
            errorMessage = ERROR_MESSAGES.NETWORK_ERROR;
        } else if (error.response?.data && typeof error.response.data === 'object' && 'message' in error.response.data) {
            errorMessage = error.response.data.message as string;
        }

        Toast.show({
            type: 'error',
            text1: 'L·ªói',
            text2: errorMessage,
        });

        return Promise.reject(error);
    },
);

export default api; 