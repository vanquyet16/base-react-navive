import { useQueryClient } from '@tanstack/react-query';
import { useMemo, useCallback } from 'react';
import { useBaseMutation } from '@/shared/hooks/useBaseMutation';
import { useBaseQuery } from '@/shared/hooks/useBaseQuery';
import { LoginRequest } from '@/shared/types';
import { authService } from '../../services';
import { authStore } from '../../store';

// ============================================================================
// QUERY KEYS
// ============================================================================

export const authKeys = {
    all: ['auth'] as const,
    me: () => [...authKeys.all, 'me'] as const,
    profile: () => [...authKeys.all, 'profile'] as const,
    tokens: () => [...authKeys.all, 'tokens'] as const,
} as const;

// ============================================================================
// QUERIES
// ============================================================================

/**
 * L·∫•y th√¥ng tin user hi·ªán t·∫°i
 */
export const useGetCurrentUser = () => {
    const { isAuthenticated } = authStore();

    // Memoize query key ƒë·ªÉ tr√°nh re-render kh√¥ng c·∫ßn thi·∫øt
    const queryKey = useMemo(() => authKeys.me(), []);

    return useBaseQuery({
        queryKey,
        queryFn: authService.getCurrentUser,
        enabled: isAuthenticated,
        staleTime: 5 * 60 * 1000, // 5 ph√∫t
        showErrorToast: false, // Kh√¥ng hi·ªÉn th·ªã toast cho query n√†y
        errorMessage: 'L·ªói khi t·∫£i th√¥ng tin ng∆∞·ªùi d√πng',
        // Th√™m retry logic t√πy ch·ªânh cho auth queries
        retry: (failureCount, error: any) => {
            // Kh√¥ng retry v·ªõi l·ªói 401 (unauthorized)
            if (error?.response?.status === 401) {
                return false;
            }
            return failureCount < 2;
        },
    });
};

/**
 * L·∫•y th√¥ng tin profile user
 */
export const useGetUserProfile = () => {
    const { isAuthenticated } = authStore();

    const queryKey = useMemo(() => authKeys.profile(), []);

    return useBaseQuery({
        queryKey,
        queryFn: () => {
            // Gi·∫£ l·∫≠p getUserProfile n·∫øu ch∆∞a c√≥ trong service
            return authService.getCurrentUser();
        },
        enabled: isAuthenticated,
        staleTime: 10 * 60 * 1000, // 10 ph√∫t - profile √≠t thay ƒë·ªïi
        showErrorToast: false,
        errorMessage: 'L·ªói khi t·∫£i th√¥ng tin profile',
    });
};

// ============================================================================
// MUTATIONS
// ============================================================================

/**
 * ƒêƒÉng nh·∫≠p
 */
export const useLogin = () => {
    const { login, setLoading } = authStore();
    // Memoize invalidate queries
    const invalidateQueries = useMemo(() => [authKeys.me(), authKeys.profile()], []);

    return useBaseMutation({
        mutationFn: (credentials: LoginRequest) => {
            console.log("üöÄ ~ useLogin ~ credentials:", credentials);
            return authService.login(credentials);
        },
        showSuccessToast: false, // Kh√¥ng hi·ªÉn th·ªã toast success m·∫∑c ƒë·ªãnh
        showErrorToast: true,
        errorMessage: 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i',
        invalidateQueries,
        onSuccessCallback: (data) => {
            login({
                token: data.token,
                refreshToken: data.refreshToken
            });
        },
        onMutate: () => {
            setLoading(true);
        },
        onSettled: () => {
            setLoading(false);
        },
    });
};

/**
 * ƒêƒÉng k√Ω
 */
export const useRegister = () => {
    const { login, setLoading } = authStore();

    // Memoize invalidate queries
    const invalidateQueries = useMemo(() => [authKeys.me(), authKeys.profile()], []);

    return useBaseMutation({
        mutationFn: (userData: { email: string; password: string; name: string }) => authService.register(userData),
        showSuccessToast: true,
        successMessage: 'ƒêƒÉng k√Ω th√†nh c√¥ng!',
        showErrorToast: true,
        errorMessage: 'ƒêƒÉng k√Ω th·∫•t b·∫°i',
        invalidateQueries,
        onSuccessCallback: (data) => {
            login(data);
        },
        onMutate: () => {
            setLoading(true);
        },
        onSettled: () => {
            setLoading(false);
        },
    });
};

/**
 * ƒêƒÉng xu·∫•t
 */
export const useLogout = () => {
    const { logout, setLoading } = authStore();
    const queryClient = useQueryClient();

    // Memoize clear function
    const clearAuthData = useCallback(() => {
        logout();
        queryClient.clear();
    }, [logout, queryClient]);

    return useBaseMutation({
        mutationFn: authService.logout,
        showSuccessToast: true,
        successMessage: 'ƒêƒÉng xu·∫•t th√†nh c√¥ng!',
        showErrorToast: false, // Kh√¥ng hi·ªÉn th·ªã l·ªói khi logout
        onSuccessCallback: clearAuthData,
        onErrorCallback: clearAuthData, // Ngay c·∫£ khi logout fail tr√™n server, v·∫´n clear local state
        onMutate: () => {
            setLoading(true);
        },
        onSettled: () => {
            setLoading(false);
        },
    });
};

/**
 * ƒê·ªïi m·∫≠t kh·∫©u
 */
export const useChangePassword = () => {
    return useBaseMutation({
        mutationFn: (data: { currentPassword: string; newPassword: string }) => authService.changePassword(data),
        showSuccessToast: true,
        successMessage: 'ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng!',
        showErrorToast: true,
        errorMessage: 'ƒê·ªïi m·∫≠t kh·∫©u th·∫•t b·∫°i',
        // Kh√¥ng invalidate queries v√¨ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn user data
    });
};

/**
 * C·∫≠p nh·∫≠t profile
 */
export const useUpdateProfile = () => {
    const queryClient = useQueryClient();

    // Memoize invalidate queries
    const invalidateQueries = useMemo(() => [authKeys.me(), authKeys.profile()], []);

    return useBaseMutation({
        mutationFn: authService.updateProfile,
        showSuccessToast: true,
        successMessage: 'C·∫≠p nh·∫≠t th√¥ng tin th√†nh c√¥ng!',
        showErrorToast: true,
        errorMessage: 'C·∫≠p nh·∫≠t th√¥ng tin th·∫•t b·∫°i',
        invalidateQueries,
        onSuccessCallback: (updatedUser) => {
            // C·∫≠p nh·∫≠t cache cho user data
            queryClient.setQueryData(authKeys.me(), updatedUser);
            queryClient.setQueryData(authKeys.profile(), updatedUser);
        },
    });
};

/**
 * Refresh token
 */
export const useRefreshToken = () => {
    const { updateTokens } = authStore();

    return useBaseMutation({
        mutationFn: authService.refreshToken,
        showSuccessToast: false,
        showErrorToast: false,
        onSuccessCallback: (data) => {
            updateTokens({ token: data.token, refreshToken: data.refreshToken });
        },
        // Kh√¥ng retry refresh token ƒë·ªÉ tr√°nh loop v√¥ h·∫°n
        retry: false,
    });
};

/**
 * Qu√™n m·∫≠t kh·∫©u
 */
export const useForgotPassword = () => {
    return useBaseMutation({
        mutationFn: (email: string) => authService.forgotPassword(email),
        showSuccessToast: true,
        successMessage: 'Email kh√¥i ph·ª•c m·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c g·ª≠i!',
        showErrorToast: true,
        errorMessage: 'L·ªói khi g·ª≠i email kh√¥i ph·ª•c m·∫≠t kh·∫©u',
    });
};

/**
 * Reset m·∫≠t kh·∫©u
 */
export const useResetPassword = () => {
    return useBaseMutation({
        mutationFn: (data: { token: string; password: string }) => authService.resetPassword(data),
        showSuccessToast: true,
        successMessage: 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng!',
        showErrorToast: true,
        errorMessage: 'L·ªói khi ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u',
    });
};

/**
 * X√°c th·ª±c email
 */
export const useVerifyEmail = () => {
    const queryClient = useQueryClient();

    return useBaseMutation({
        mutationFn: (token: string) => {
            // Gi·∫£ l·∫≠p verifyEmail n·∫øu ch∆∞a c√≥ trong service
            return Promise.resolve({ success: true });
        },
        showSuccessToast: true,
        successMessage: 'X√°c th·ª±c email th√†nh c√¥ng!',
        showErrorToast: true,
        errorMessage: 'L·ªói khi x√°c th·ª±c email',
        invalidateQueries: [authKeys.me()],
        onSuccessCallback: () => {
            // Invalidate user data sau khi verify email
            queryClient.invalidateQueries({ queryKey: authKeys.me() });
        },
    });
}; 